---
title: Philosophy? For programming?
category: article
---

 While in college, as i progress through my computer engineering degree, i have come to realize something (i'm in first year and there are five years, so this might as well be very obvious in the future): there is a very important relationship between programming and philosophy. Let me elaborate a bit.

What i like about the career i chose is that i get to create stuff from scratch. Mechanic engineers grab existing stuff, mesh it together, and create new stuff. For example, a car is an assembly of several metals. Industrial engineers seek to optimize already existing stuff, whether it be how a rice farm works or how a book store can maximize its profit.

Computer engineering doesn't quite deal with this. Though it messes with optimization (possibly the main aim of engineering as a discipline), the stuff computer engineers create is not tangible, or at least, not immediately tangible (please notify me if you find a for-loop in the wilderness). This is why i find the topic of computer science so intriguing: it is a science with no tangible subject! Biologists can dissect frogs and germinate seeds; physicists (excluding everything quantum-related) can measure the speed of light using many, many methods; computer scientists can, well, spend a lifetime arguing over how P and NP are different.

This observation is perhaps quite logical: the nature of computation is abstract, and so is whatever is produced by it. What i find fascinating is the consequence of this:

If we can't physically interact with what we create, then are we creating something  entirely new? If so, how do we get to organize it?

This is an issue that i think mathematicians encountered early. Needless to say, this issue has been solved in this field: the answer is yes, and there is a quite solid organization that has been prevalent for quite some time on how to study mathematics. For instance, in calculus: first limits, then derivation, the integration, etc; in algebra: first vectors, then matrices, then euclidean spaces, etc.

This question is still prevalent in computer science, though. How are we to formally arrange the knowledge required for programming? In universities, a common practice is to start teaching a language and then let students find what they are interested in (this is what my university does). But this narrows the scope of what computer science has to offer! It is like teaching calculus but only teaching how to derive and integrate a family of functions. This may not be the best approach to programming, but it is effective for now, so i don't think we'll be changing this anytime soon. But what i do think must be introduced is philosophy for programming. Yes, philosophy, that major everyone deems useless. Why? Well,
As the field of computer science is very abstract and wide, we must choose the way in which we want to navigate it. To organize all of our knowledge under an epistemological framework we may be able to have a firmer grasp of it;


Philosophical ideas can be customized. We can take an idea and adapt it to fit our cultural context, or we can take very old ideas found in very old books and refine them. Perhaps the most famous idea is Plato's two colliding "worlds", which has been recycled under many names: Descartes called it dualism, Hegel called it dialectics, Marx called it materialism, etc. The idea of a sassy, meme man was perfected throughout time to fit many different contexts. This can be made with virtually any philosophical idea.


There are, have been, and will be, many philosophers with many ideas throughout history. I can choose the "philosophical framework" which better fits the task i'm doing. Want to do something word-related? Wittgenstein is your man; just mad at how stressful programming in Lisp is? Schopenhauer is your man (i think); you have absolutely no clue of what is causing that bug that makes your entire program crash? You can read Hegel and be just as clueless as you were before.

This relation came to me while i was in Programming class. I admire my teacher because of how he approaches both the his students, and the course.

For him, we are his colleagues: he pressures us, plays jokes on us, and rages whenever we make a static reference to a non-static method in Java. All of this with one objective: to give us a snapshot of how the work environment will be when we graduate (a bit early, but yeah). His idea is brilliant, and i think all of my classmates can agree.

From the first moment it was clear to me how much he knew: the first class he talked for around five minutes about how Java is a shitty language and why we should change to this god-like language called Smalltalk. And, suddenly, he introduced Wittgenstein to the conversation. I was really confused for about 10 minutes, during which i tried to find a relation between programming and philosophy (and kind of succeeded at).

This entry contains many dead-end ideas, misinterpretations, and vague arguments, but i wanted to document the moment at which i realized how closely tied two fields i'm passionate about are. Looking forward to read bullshit philosophy and justify it as studying for my programming class midterms!



